<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="yes" name="apple-touch-fullscreen"><meta content="telephone=no,email=no" name="format-detection"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet"><script src="https://use.fontawesome.com/adaf0e149c.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/monokai_sublime.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/markdown-github.css"><title>Logical World</title><script src="/js/googleAnalytics.js"></script></head><body><div id="postContainer"><div id="postTop"><h4 id="logo">Be an interesting girl</h4><br><br><h2 id="postTitle">七大排序算法解析与Python实现   //在此处添加你的标题。</h2><br><span aria-hidden="true" class="postTime fa fa-calendar">2017-11-10</span><br><br></div><section id="articleDiv"><p>#前言: </p><br><p><strong>理解算法思想很重要！<br>理解算法思想很重要！<br>理解算法思想很重要！</strong><br><strong>之后尝试自己独立码代码对算法的理解更深刻！</strong></p><br><p><strong><em>本文章所有算法默认从小到大排序。</em></strong></p><br><p>##1. 冒泡排序(Bubble Sort)</p><br><p>####自然语言描述<br>按照列表中待排序的先后顺序，依次比较相邻的两个数，若两者是升序则不做任何操作，否则交换两者位置。</p><br><p>####核心算法举例<br>以第一趟为例</p><br><p>1 5 7 3 9 2 6 8 <code>1 与 5比较，不变</code></p><br><p>1 5 7 3 9 2 6 8 <code>5 与 7比较，不变</code></p><br><p>1 5 <strong>3 7</strong> 9 2 6 8 <code>7 与 3比较，交换位置</code></p><br><p>1 5 3 7 9 2 6 8 <code>7 与 9比较，不变</code></p><br><p>1 5 3 7 <strong>2 9</strong> 6 8 <code>9 与 2比较， 交换位置</code></p><br><p>1 5 3 7 2 <strong>6 9</strong> 8 <code>9 与 6比较，交换位置</code></p><br><p>1 5 3 7 2 6 <strong>8 9</strong> <code>9 与 8比较，交换位置</code></p><br><p>所以第一趟结束后，排序结果为<br>1 5 3 7 2 6 8 <strong>9</strong> <code>9为最大数，后续不需要比较</code></p><br><p>####算法优劣分析</p><br><ul><br><li>一共比较((N-1)+(N-2)+…+2+1)次</li><br><li>最好情况下交换0次</li><br><li>最坏情况下交换((N-1)+(N-2)+…+2+1)次</li><br><li>平均时间复杂度O(n²)</li><br></ul><br><p>####算法实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-<em>-coding=UTF-8-</em>-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title"><strong>init</strong></span><span class="params">(self,list<em>=[])</span>:</span></span><br><span class="line">        self.list</em> = list_</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current<em>list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ascent<em>sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(self.list</em>)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(self.list<em>)-i<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> self.list</em>[j]&gt;self.list<em>[j+<span class="number">1</span>]:</span><br><span class="line">                    temp = self.list</em>[j]</span><br><span class="line">                    self.list<em>[j] = self.list</em>[j+<span class="number">1</span>]</span><br><span class="line">                    self.list_[j+<span class="number">1</span>] = temp</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = BubbleSort([<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure></p><br><p>##2. 选择排序算法(Selection Sort)</p><br><p>####自然语言描述</p><br><ul><br><li>遍历列表所有元素，最小（大）的元素放在最左（右）边。</li><br><li>确定第一个元素位置后，遍历剩下的所有元素，最小（大）的元素放在最左（右）边。</li><br><li>以此类推，直到倒数第二个元素。</li><br></ul><br><p>####核心算法举例<br>第二趟比较为例(以找最小数为例)</p><br><p><code>此时min_index = 1</code></p><br><p>1 7 5 9 4<br><code>7 与 5 作比较，min_index更新为2</code></p><br><p><code>5 与 9 作比较，min_index不变</code></p><br><p><code>5 与 4 作比较，min<em>index更新为4</code></p><br><p><code>将index = 4与index=1的元素交换位置</code></p><br><p>1 4 5 9 7</p><br><p>####算法优劣分析</p><br><ul><br><li>一共比较((N-1)+(N-2)+…+2+1)次，交换N次。</li><br><li>平均时间复杂度O(n²)</li><br></ul><br><p>####算法实现</p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-<em>-coding = utf-8-</em>-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title"><strong>init</strong></span><span class="params">(self,list</em>=[])</span>:</span></span><br><span class="line">        self.list<em> = list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current<em>list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ascent<em>sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(self.list</em>)<span class="number">-1</span>):</span><br><span class="line">            min_index, swap<em>temp = i, i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(self.list</em>)<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> self.list_[min<em>index] &gt; self.list</em>[j+<span class="number">1</span>]:</span><br><span class="line">                    min_index = j + <span class="number">1</span></span><br><span class="line">            swap<em>temp = self.list</em>[min<em>index]</span><br><span class="line">            self.list</em>[min<em>index] = self.list</em>[i]</span><br><span class="line">            self.list_[i] = swap<em>temp</span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = SelectionSort([<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure><br><p>##3. 直接插入算法(Insertion Sort)</p><br><p>####自然语言描述<br>在前面已经排好序的列表中插入新元素。步骤：</p><br><ul><br><li>将第二元素与第一个元素比较，如果小于第一个元素则交换位置，反之不变。</li><br><li>将第三个元素分别与前两个元素比较(这里的算法用的是与之前一个的位置比较)，插入合适位置。</li><br><li>以此类推，直到最后一个元素。</li><br><li>####核心算法举例</li><br></ul><br><p>第二趟比较为例<br><code>此时 current_value = 1</code></p><br><p>5 7 <strong>1</strong> </p><br><p>  <code>current_value = 1 与7作比较</code></p><br><p>5 7 7  </p><br><p><code>current_value = 1 与5作比较</code></p><br><p>5 5 7</p><br><p><code>将 current<em>value = 1 插入</code></p><br><p>1 5 7</p><br><p>####算法优劣分析</p><br><ul><br><li>最坏的情况下，一共比较并交换（1+2+…+(N-1)）次</li><br><li>最好的情况下，只需比较(N-1)次，无需交换</li><br><li>平均时间复杂度O(n²)</li><br><li>稳定</li><br></ul><br><blockquote><br><p>插入排序<strong>适用于数量较小，部分或者全部排序过的</strong>列表。尽管插入排序的时间复杂度也是O(n²)，但一般情况下，插入排序会比冒泡排序快一倍，要比选择排序还要快一点。并且，直接插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率。</p><br></blockquote><br><p>####算法实现</p><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-<em>-coding = UTF-8-</em>-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title"><strong>init</strong></span><span class="params">(self,list</em>=[])</span>:</span></span><br><span class="line">        self.list<em> = list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current<em>list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ascent<em>sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(self.list</em>)):</span><br><span class="line">            position = i</span><br><span class="line">            current<em>value = self.list</em>[i]</span><br><span class="line">            <span class="keyword">while</span> position&gt;<span class="number">0</span> <span class="keyword">and</span> self.list<em>[position<span class="number">-1</span>]&gt;self.list</em>[position]:</span><br><span class="line">                self.list<em>[position] = self.list</em>[position<span class="number">-1</span>]</span><br><span class="line">                position = position - <span class="number">1</span></span><br><span class="line">            self.list_[position] = current<em>value</span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = InsertionSort([<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current<em>list()</span><br></pre></td></tr></table></figure><br><p>##4. 希尔排序(Shell Sort)</p><br><p>####自然语言描述<br>直接插入算法一趟只能为数据移动一位，比较低效。希尔排序作为直接插入算法的优化，又称<strong>缩小增量排序</strong>、<strong>递减增量排序</strong>。</p><br><p>以步长分区，对跳过步长的数进行直接插入算法排序，直至步长为1。</p><br><blockquote><br><p><strong><em>步长</em></strong>是希尔排序的精髓，已知的最好步长序列是由<strong><em>Sedgewick</em></strong>提出的 1，5，19，41，109，…</p><br></blockquote><br><p>####核心算法举例<br>原列表：[4,6,8,2,9,3,7,5,1]<br>步长增量：9/2=<strong><em>4</em></strong>, 4/2=<strong><em>2</em></strong>, 2/2=<strong><em>1</em></strong> (<em>Note</em>: 取列表长度的一半作为最初步长，这里的步长使用的是<strong><em>Donald Shell的建议</em></strong>)<br><code>第一趟(步长为4)：</code></p><br><blockquote><br><p>原列表 4 6 8 2 9 3 7 5 1，分组后为：<br>4 6 8 2<br>9 3 7 5<br>1<br>排序后为：<br>1 3 7 2<br>4 6 8 5<br>9<br>即排序后列表顺序为：<br>1 3 7 2 4 6 8 5 9</p><br></blockquote><br><p><code>第二趟(步长为2)</code></p><br><blockquote><br><p>待排序列表1 3 7 2 4 6 8 5 9，分组后为：<br>1 3<br>7 2<br>4 6<br>8 5<br>9<br>排序后为：<br>1 2<br>4 3<br>7 5<br>8 6<br>9<br>即排序后列表顺序为：<br>1 2 4 3 7 5 8 6 9</p><br></blockquote><br><p><code>第三趟(步长为1), 即直接插入排序</code></p><br><blockquote><br><p>待排序列表1 2 4 3 7 5 8 6 9<br>排序后列表顺序为：1 2 3 4 5 6 7 8 9</p><br></blockquote><br><p>####算法优劣分析</p><br><ul><br><li>希尔排序比插入排序要快，甚至在小数组中比<strong>快速排序</strong>和<strong>堆排序</strong>还快，但是在涉及大量数据时希尔排序还是比<strong>快速排序</strong>慢。</li><br><li>不稳定</li><br><li>平均时间复杂度O(nlog2n)「n倍的log以2为底n」<br>####算法实现<br><strong><em>巧记：将直接插入算法的步长从1改为gap，加入限制条件gap &gt; 0即可</em></strong></li><br></ul><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-<em>-coding = utf-8 -</em>-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title"><strong>init</strong></span><span class="params">(self, list</em>=[])</span>:</span></span><br><span class="line">        self.list<em> = list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current<em>list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ascent<em>sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        gap = len(self.list</em>)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(self.list_)):</span><br><span class="line">                current<em>value = self.list</em>[i]</span><br><span class="line">                position = i    </span><br><span class="line">                <span class="keyword">while</span> position &gt;<span class="number">0</span> <span class="keyword">and</span> self.list_[position - gap] &gt; current<em>value:</span><br><span class="line">                    self.list</em>[position] = self.list<em>[position - gap]</span><br><span class="line">                    position = position - gap</span><br><span class="line">                self.list</em>[position] = current<em>value</span><br><span class="line">            gap = gap/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.list</em></span><br><span class="line"></span><br><span class="line">list1 = ShellSort([<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure><br><p>##5. 归并排序(Merge Sort)</p><br><p>####自然语言描述<br>将两个有序表合并成一个有序表。归并排序算法依赖于归并操作。<br><img src="http://upload-images.jianshu.io/upload_images/8741154-ac731598637727b3.gif?imageMogr2/auto-orient/strip" alt="from Wikipedia"></p><br><blockquote><br><p>两个有序表，left = [0,3,5,7], right = [1,4]，<br>合成的有序列表result = []<br>left[0] &lt; right[0]  —-&gt;  result = [0]<br>left[1] &gt; right[0] —-&gt;  result = [0,1]<br>left[1] &lt; right[1] —-&gt; result = [0,1,3]<br>left[2] &gt; right[1] —-&gt; result = [0,1,3,4]<br>此时right[]为空，将left[]剩余的元素依次放入result列表中：result = [0,1,3,4,5,7]</p><br></blockquote><br><p>####两种核心算法</p><br><p>######递归法<br><a href="http://www.jianshu.com/p/3ad5373465fd" target="_blank" rel="external">递归算法思想参考这里</a></p><br><blockquote><br><p>设计递归，将复杂的问题分解为最小规模子问题。</p><br><ul><br><li>将列表分解为 两个更小的列表。</li><br><li><strong><em>递归分解，将更小的列表继续分解，直到达到最小规模，也就是只有一个元素的时候</em></strong>。</li><br><li>对已经排序好的列表 进行合并。单个元素的列表，认为是已经排序好的。</li><br></ul><br></blockquote><br><p><img src="http://upload-images.jianshu.io/upload_images/8741154-25e9d65aace0f91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="from Wikipedia"></p><br><p>######递归python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-<em>-coding=utf-8-</em>-</span></span><br><span class="line"><span class="comment">#递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(seq=[])</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(seq) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> seq</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = len(seq)/<span class="number">2</span></span><br><span class="line">        left = []</span><br><span class="line">        right = []</span><br><span class="line">        left = mergeSort(seq[:mid])</span><br><span class="line">        right = mergeSort(seq[mid:])</span><br><span class="line">        <span class="keyword">return</span> merge(left,right)</span><br><span class="line"><span class="comment">#将排好序的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left=[],right=[])</span>:</span></span><br><span class="line">    <span class="comment">#i, j are index for left and right seperately</span></span><br><span class="line">    i, j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line">    <span class="comment">#将剩余的部分依次加入result</span></span><br><span class="line">    result = result + left[i:]</span><br><span class="line">    result = result + right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="keyword">print</span> mergeSort(list1)</span><br><span class="line"><span class="comment">#time consume</span></span><br><span class="line"><span class="keyword">import</span> random,time</span><br><span class="line">start_time = time.time()</span><br><span class="line">seq = random.sample(range(<span class="number">10000</span>), <span class="number">10000</span>) <span class="comment">#random.sample(取值范围, 获取的个数)</span></span><br><span class="line">result = mergeSort(seq)</span><br><span class="line"><span class="keyword">print</span> <span class="string">‘Time consume:&#123;&#125;’</span>.format(time.time()-start_time)</span><br></pre></td></tr></table></figure></p><br><p>######非递归法（迭代法）<br>从最小的子问题开始解决，直到复杂的问题。要搞清每次排序归并的对象。<br><img src="http://upload-images.jianshu.io/upload_images/4131789-ae20b2d875793547.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="非递归算法（迭代法）"></p><br><p>第一次：我们将数组分为 8个子数组 每个数组 1 个元素，对相邻的两个数组进行排序合并。<br>第二次：我们将数组分为 4个子数组 每个数组 2 个元素，对相邻的两个数组进行排序合并。<br>第三次：我们将数组分为 2个子数组 每个数组 4 个元素，对相邻的两个数组进行排序合并。<br>至此：排序完毕。<br><strong><em>分析</em></strong><br>第一步：每一次子数组的元素个数</p><br><blockquote><br><p>k = 1 #子数组的个数<br>while k &lt;len(seq):<br>      k = k<em>2</p><br></blockquote><br><p>第二步：确定要合并的两个相邻数组的区间[low:mid)[mid:height)</p><br><blockquote><br><p>low = low(之前的low) +2<em>k<br>mid = low(现在的low)+k<br>height = low(现在的low) + 2</em>k<br>并且，<br>height不能越界（不能超过数组长度）；<br>mid不能大于height（mid大于height说明此时子数组个数不足k，那么这个时候该子数组不给予拆分直接pass，下图给予说明）</p><br></blockquote><br><p><img src="http://upload-images.jianshu.io/upload_images/4131789-6dc1e77c241898fa.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="来自http://www.jianshu.com/p/3f27384387c1"></p><br><p>######非递归python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-:-coding=utf-8-</em>-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title"><strong>init</strong></span><span class="params">(self,seq=[])</span>:</span></span><br><span class="line">        self.seq = seq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_seq</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.seq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ascent_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">        k = <span class="number">1</span>         <span class="comment">#子数组元素的个数</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; len(self.seq):</span><br><span class="line">            low = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; len(self.seq):</span><br><span class="line">                height = min(low + <span class="number">2</span><em>k, len(self.seq))</span><br><span class="line">                mid = low + k</span><br><span class="line">                <span class="keyword">if</span> mid &lt; height:</span><br><span class="line">                    <span class="string">‘’’mergeSort’’’</span></span><br><span class="line">                    left = self.seq[low:mid]</span><br><span class="line">                    right = self.seq[mid:height]</span><br><span class="line">                    result =[]</span><br><span class="line">                    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">                        <span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">                            result.append(left[i])</span><br><span class="line">                            i += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            result.append(right[j])</span><br><span class="line">                            j += <span class="number">1</span></span><br><span class="line">                    result = result + left[i:]</span><br><span class="line">                    result = result + right[j:]</span><br><span class="line">                    <span class="string">‘’’将原始数组的[low,height)替代为已经排好序的数组’’’</span></span><br><span class="line">                    self.seq[low:height] = result</span><br><span class="line">                low = low + <span class="number">2</span></em>i</span><br><span class="line"></span><br><span class="line">            k <em>= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> self.seq</span><br><span class="line">list1 = MergeSort([<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_seq()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_seq()</span><br></pre></td></tr></table></figure></p><br><p>##6. 堆排序(HeapSort)<br>堆排序是对简单选择排序的一种优化。<br>堆的定义及性质见<a href="http://www.jianshu.com/p/42d08c8ed18a" target="_blank" rel="external">这里</a>。</p><br><p>####<strong>堆的主要性质</strong>：</p><br><ul><br><li>若根的index为1，则最后一个非叶子节点的index为len(seq)/2。此时对于index为i的节点，其左节点的index为2<em>i；右节点的index为2</em>i+1。</li><br><li>若根的index为0，最后一个非叶子节点的index为len(seq)/2-1。此时对于index为i的节点；其左节点的index为2<em>i+1，右节点的index为2</em>i+2。</li><br></ul><br><p>####堆排序需要解决两个主要的问题：</p><br><ul><br><li>P1：如何将无序的列表构建成最小堆<br><img src="http://upload-images.jianshu.io/upload_images/1894691-cb4e77ab86413fd9.png?imageMogr2/auto-orient/strip" alt="P1：如何从无序数组构建最小堆"></li><br><li>P2：将最小堆的顶部取出后如何重建最小堆<br><img src="http://upload-images.jianshu.io/upload_images/1894691-49f3c7196f85fe6f.png?imageMogr2/auto-orient/strip" alt="P2：如何重构最小堆"></li><br></ul><br><p>堆排序过程演示：<br><img src="http://upload-images.jianshu.io/upload_images/4251424-e997b3365c9aa77f.gif?imageMogr2/auto-orient/strip" alt="from Wikipedia"></p><br><p>####堆排序的三个步骤：</p><br><ul><br><li>构建堆</li><br><li>调整堆</li><br><li>堆排序</li><br></ul><br><p>####堆排序python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-</em>-coding=utf-8-<em>-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="string">“””建立一个堆”””</span></span><br><span class="line">    <span class="comment">#根据完全二叉树的性质，根的index为0，非叶子节点的index为1至len(seq)/2-1，</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)/<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        max_heap(seq, len(seq), i)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heap</span><span class="params">(seq, heap_size, index)</span>:</span></span><br><span class="line">    <span class="string">“””调整列表中的元素以保证以index为根的堆是一个最大堆—&gt;从而最终得到从小到大的排列顺序”””</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将当前结点与其左右子节点比较，将较大的结点与当前结点交换，然后递归地调整子树</span></span><br><span class="line">    left_child = <span class="number">2</span> </em> index + <span class="number">1</span></span><br><span class="line">    right_child = left_child + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left_child &lt; heap_size <span class="keyword">and</span> seq[left_child] &gt; seq[index]:</span><br><span class="line">        largest = left_child</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = index</span><br><span class="line">    <span class="keyword">if</span> right_child &lt; heap_size <span class="keyword">and</span> seq[right_child] &gt; seq[largest]:</span><br><span class="line">        largest = right_child</span><br><span class="line">    <span class="keyword">if</span> largest != index:</span><br><span class="line">        seq[index], seq[largest] = seq[largest], seq[index] <span class="comment">#python特有，不需temp</span></span><br><span class="line">        max_heap(seq, heap_size, largest)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(to_sort_list)</span>:</span></span><br><span class="line">    <span class="string">“””堆排序”””</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先将列表调整为堆</span></span><br><span class="line">    build_max_heap(to_sort_list)</span><br><span class="line">    heap_size = len(to_sort_list)</span><br><span class="line">    <span class="comment"># 调整后列表(此时为堆）的第一个元素就是这个列表中最大的元素，将其与最后一个元素交换，然后将剩余的列表再调整为最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(to_sort_list) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        to_sort_list[i], to_sort_list[<span class="number">0</span>] = to_sort_list[<span class="number">0</span>], to_sort_list[i]</span><br><span class="line">        heap_size -= <span class="number">1</span></span><br><span class="line">        max_heap(to_sort_list, heap_size, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">to_sort_list = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">heap_sort(to_sort_list)</span><br><span class="line"><span class="keyword">print</span> to_sort_list</span><br></pre></td></tr></table></figure></p><br><p>####算法优劣分析</p><br><ul><br><li>平均时间复杂度O(nlogn)</li><br><li>空间复杂度O(1)</li><br></ul><br><p>##7. 快速排序(QuikSort)</p><br><p>####自然语言描述<br>对冒泡排序的有效改进。快速排序是一种不稳定的排序算法，<strong>即多个相同的值的相对位置也许会在算法结束时产生变动</strong>。</p><br><p>假设要排序的列表<code>a[0]</code>,<code>a[1]</code>…<code>a[n-1]</code>，首先任意选取一个数据（通常选用<code>a[0]</code>）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。整个排序过程可以递推进行，从而使整个列表变得有序。</p><br><p><strong><em>更具体一些：</em></strong></p><br><ul><br><li>设置两个变量<code>i</code>、<code>j</code>，排序开始的时候：<code>i=0</code>，<code>j=n-1</code>；</li><br><li>以第一个数组元素作为关键数据，赋值给<code>key</code>，即<code>key = a[0]</code>；</li><br><li>从<code>j</code>开始向前搜索 (顺序不能调转，因为你的比较对象是<code>a[0]</code>)，即由后开始向前搜索，找到第一个小于<code>key</code>的值<code>list[j]</code>，将<code>list[j]</code>赋值给<code>list[i]</code>, 并令<code>i++</code>；</li><br><li>从<code>i</code>开始向后搜索，即由前开始向后搜索，找到第一个大于<code>key</code>的<code>list[i]</code>，将<code>list[i]</code>赋值给<code>list[j]</code>，并令<code>j–</code>；</li><br><li>重复第3、4步，直到<code>i = j</code>（下面有图解说明这一结束条件）。<br><strong><em>Note:</em></strong></li><br><li>3,4步中，没找到符合条件时，改变<code>j</code>、<code>i</code>的值，使得<code>j = j-1</code>，<code>i = i+1</code>，直至找到为止。</li><br><li>找到符合条件的值，进行交换的时候<code>i</code>， <code>j</code>指针位置不变，只交换所指的值。</li><br><li><code>i == j</code>这一过程一定正好是<code>i++</code>或<code>j–</code>完成的时候，此时令循环结束。</li><br></ul><br><p><strong>不多说了，上图！</strong></p><br><p><strong>一趟比较的图解：</strong></p><br><p><img src="http://upload-images.jianshu.io/upload_images/8741154-12890818c6bd95e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字太丑凑活看"></p><br><p>####快速排序python实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-<em>-coding=UTF-8-</em>-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(a,left,right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(a) &lt;= <span class="number">1</span> <span class="keyword">or</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> left &gt;= len(a) <span class="keyword">or</span> right &lt;= left:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    key = a[left]</span><br><span class="line">    i, j = left, right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> a[j] &gt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            a[i] = a[j]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> a[i] &lt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a[i] &gt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">            a[j] = a[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    a[i] = key</span><br><span class="line">    quick_sort(a, left, i<span class="number">-1</span>)</span><br><span class="line">    quick_sort(a, i+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">67</span>,<span class="number">23</span>,<span class="number">89</span>,<span class="number">35</span>,<span class="number">28</span>,<span class="number">90</span>,<span class="number">10</span>,<span class="number">24</span>]</span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = len(list1)<span class="number">-1</span></span><br><span class="line">print(quick_sort(list1, left, right))</span><br></pre></td></tr></table></figure></p><br><p>##总结比较<br><img src="http://upload-images.jianshu.io/upload_images/4251424-8d79360387a74e70.png?imageMogr2/auto-orient/strip" alt="七大算法的比较"></p>
</section></div><script src="/js/jquery.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/start.js"></script></body></html>