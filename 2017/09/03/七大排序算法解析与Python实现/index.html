<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="前言:理解算法思想很重要！理解算法思想很重要！理解算法思想很重要！之后尝试自己独立码代码对算法的理解更深刻！
本文章所有算法默认从小到大排序。
1. 冒泡排序(Bubble Sort)自然语言描述按照列表中待排序的先后顺序，依次比较相邻的两个数，若两者是升序则不做任何操作，否则交换两者位置。
核心算">
    

    <!--Author-->
    
        <meta name="author" content="An Jingjing">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="七大排序算法解析与Python实现"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="An&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>七大排序算法解析与Python实现 - An&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-109494500-1', 'auto');
        ga('send', 'pageview');

    </script>



    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Logical World</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="http://www.jianshu.com/u/fd50a7c19306">
                            
                                My Jianshu
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://www.zhihu.com/people/crystalajj">
                            
                                My Zhihu
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>七大排序算法解析与Python实现</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2017.09.03
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/python/">#python</a> <a href="/tags/sort-algorithm/">#sort algorithm</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/Algorithm/">Algorithm</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h1><p><strong>理解算法思想很重要！<br>理解算法思想很重要！<br>理解算法思想很重要！</strong><br><strong>之后尝试自己独立码代码对算法的理解更深刻！</strong></p>
<p><strong><em>本文章所有算法默认从小到大排序。</em></strong></p>
<h2 id="1-冒泡排序-Bubble-Sort"><a href="#1-冒泡排序-Bubble-Sort" class="headerlink" title="1. 冒泡排序(Bubble Sort)"></a>1. 冒泡排序(Bubble Sort)</h2><h4 id="自然语言描述"><a href="#自然语言描述" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><p>按照列表中待排序的先后顺序，依次比较相邻的两个数，若两者是升序则不做任何操作，否则交换两者位置。</p>
<h4 id="核心算法举例"><a href="#核心算法举例" class="headerlink" title="核心算法举例"></a>核心算法举例</h4><p>以第一趟为例</p>
<p>1 5 7 3 9 2 6 8 <code>1 与 5比较，不变</code></p>
<p>1 5 7 3 9 2 6 8 <code>5 与 7比较，不变</code></p>
<p>1 5 <strong>3 7</strong> 9 2 6 8 <code>7 与 3比较，交换位置</code></p>
<p>1 5 3 7 9 2 6 8 <code>7 与 9比较，不变</code></p>
<p>1 5 3 7 <strong>2 9</strong> 6 8 <code>9 与 2比较， 交换位置</code></p>
<p>1 5 3 7 2 <strong>6 9</strong> 8 <code>9 与 6比较，交换位置</code></p>
<p>1 5 3 7 2 6 <strong>8 9</strong> <code>9 与 8比较，交换位置</code></p>
<p>所以第一趟结束后，排序结果为<br>1 5 3 7 2 6 8 <strong>9</strong> <code>9为最大数，后续不需要比较</code></p>
<h4 id="算法优劣分析"><a href="#算法优劣分析" class="headerlink" title="算法优劣分析"></a>算法优劣分析</h4><ul>
<li>一共比较((N-1)+(N-2)+…+2+1)次</li>
<li>最好情况下交换0次</li>
<li>最坏情况下交换((N-1)+(N-2)+…+2+1)次</li>
<li>平均时间复杂度O(n²)</li>
</ul>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding=UTF-8-*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,list_=[])</span>:</span></span><br><span class="line">		self.list_ = list_</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_current_list</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.list_</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ascent_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(self.list_)<span class="number">-1</span>):</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(self.list_)-i<span class="number">-1</span>):</span><br><span class="line">				<span class="keyword">if</span> self.list_[j]&gt;self.list_[j+<span class="number">1</span>]:</span><br><span class="line">					temp = self.list_[j]</span><br><span class="line">					self.list_[j] = self.list_[j+<span class="number">1</span>]</span><br><span class="line">					self.list_[j+<span class="number">1</span>] = temp</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = BubbleSort([<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序算法-Selection-Sort"><a href="#2-选择排序算法-Selection-Sort" class="headerlink" title="2.选择排序算法(Selection Sort)"></a>2.选择排序算法(Selection Sort)</h2><h4 id="自然语言描述-1"><a href="#自然语言描述-1" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><ul>
<li>遍历列表所有元素，最小（大）的元素放在最左（右）边。</li>
<li>确定第一个元素位置后，遍历剩下的所有元素，最小（大）的元素放在最左（右）边。</li>
<li>以此类推，直到倒数第二个元素。</li>
</ul>
<h4 id="核心算法举例-1"><a href="#核心算法举例-1" class="headerlink" title="核心算法举例"></a>核心算法举例</h4><p>第二趟比较为例(以找最小数为例)</p>
<p><code>此时min_index = 1</code></p>
<p>1 7 5 9 4<br><code>7 与 5 作比较，min_index更新为2</code></p>
<p><code>5 与 9 作比较，min_index不变</code></p>
<p><code>5 与 4 作比较，min_index更新为4</code></p>
<p><code>将index = 4与index=1的元素交换位置</code></p>
<p>1 4 5 9 7</p>
<h4 id="算法优劣分析-1"><a href="#算法优劣分析-1" class="headerlink" title="算法优劣分析"></a>算法优劣分析</h4><ul>
<li>一共比较((N-1)+(N-2)+…+2+1)次，交换N次。</li>
<li>平均时间复杂度O(n²)</li>
</ul>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding = utf-8-*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,list_=[])</span>:</span></span><br><span class="line">		self.list_ = list_</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_current_list</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.list_</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ascent_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(self.list_)<span class="number">-1</span>):</span><br><span class="line">			min_index, swap_temp = i, i</span><br><span class="line">			<span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(self.list_)<span class="number">-1</span>):</span><br><span class="line">				<span class="keyword">if</span> self.list_[min_index] &gt; self.list_[j+<span class="number">1</span>]:</span><br><span class="line">					min_index = j + <span class="number">1</span></span><br><span class="line">			swap_temp = self.list_[min_index]</span><br><span class="line">			self.list_[min_index] = self.list_[i]</span><br><span class="line">			self.list_[i] = swap_temp</span><br><span class="line">		<span class="keyword">return</span> self.list_</span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = SelectionSort([<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure>
<h2 id="3-直接插入算法-Insertion-Sort"><a href="#3-直接插入算法-Insertion-Sort" class="headerlink" title="3.直接插入算法(Insertion Sort)"></a>3.直接插入算法(Insertion Sort)</h2><h4 id="自然语言描述-2"><a href="#自然语言描述-2" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><p>在前面已经排好序的列表中插入新元素。步骤：</p>
<ul>
<li>将第二元素与第一个元素比较，如果小于第一个元素则交换位置，反之不变。</li>
<li>将第三个元素分别与前两个元素比较(这里的算法用的是与之前一个的位置比较)，插入合适位置。</li>
<li>以此类推，直到最后一个元素。</li>
<li><h4 id="核心算法举例-2"><a href="#核心算法举例-2" class="headerlink" title="核心算法举例"></a>核心算法举例</h4></li>
</ul>
<p>第二趟比较为例<br><code>此时 current_value = 1</code></p>
<p>5 7 <strong>1</strong> </p>
<p>  <code>current_value = 1 与7作比较</code></p>
<p>5 7 7  </p>
<p><code>current_value = 1 与5作比较</code></p>
<p>5 5 7</p>
<p><code>将 current_value = 1 插入</code></p>
<p>1 5 7</p>
<h4 id="算法优劣分析-2"><a href="#算法优劣分析-2" class="headerlink" title="算法优劣分析"></a>算法优劣分析</h4><ul>
<li>最坏的情况下，一共比较并交换（1+2+…+(N-1)）次</li>
<li>最好的情况下，只需比较(N-1)次，无需交换</li>
<li>平均时间复杂度O(n²)</li>
<li>稳定</li>
</ul>
<blockquote>
<p>插入排序<strong>适用于数量较小，部分或者全部排序过的</strong>列表。尽管插入排序的时间复杂度也是O(n²)，但一般情况下，插入排序会比冒泡排序快一倍，要比选择排序还要快一点。并且，直接插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率。</p>
</blockquote>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding = UTF-8-*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,list_=[])</span>:</span></span><br><span class="line">        self.list_ = list_</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_current_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list_</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ascent_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(self.list_)):</span><br><span class="line">    		position = i</span><br><span class="line">    		current_value = self.list_[i]</span><br><span class="line">    		<span class="keyword">while</span> position&gt;<span class="number">0</span> <span class="keyword">and</span> self.list_[position<span class="number">-1</span>]&gt;self.list_[position]:</span><br><span class="line">    			self.list_[position] = self.list_[position<span class="number">-1</span>]</span><br><span class="line">    			position = position - <span class="number">1</span></span><br><span class="line">    		self.list_[position] = current_value</span><br><span class="line">    	<span class="keyword">return</span> self.list_</span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = InsertionSort([<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure>
<h2 id="4-希尔排序-Shell-Sort"><a href="#4-希尔排序-Shell-Sort" class="headerlink" title="4. 希尔排序(Shell Sort)"></a>4. 希尔排序(Shell Sort)</h2><h4 id="自然语言描述-3"><a href="#自然语言描述-3" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><p>直接插入算法一趟只能为数据移动一位，比较低效。希尔排序作为直接插入算法的优化，又称<strong>缩小增量排序</strong>、<strong>递减增量排序</strong>。</p>
<p>以步长分区，对跳过步长的数进行直接插入算法排序，直至步长为1。</p>
<blockquote>
<p><strong><em>步长</em></strong>是希尔排序的精髓，已知的最好步长序列是由<strong><em>Sedgewick</em></strong>提出的 1，5，19，41，109，…</p>
</blockquote>
<h4 id="核心算法举例-3"><a href="#核心算法举例-3" class="headerlink" title="核心算法举例"></a>核心算法举例</h4><p>原列表：[4,6,8,2,9,3,7,5,1]<br>步长增量：9/2=<strong><em>4</em></strong>, 4/2=<strong><em>2</em></strong>, 2/2=<strong><em>1</em></strong> (<em>Note</em>: 取列表长度的一半作为最初步长，这里的步长使用的是<strong><em>Donald Shell的建议</em></strong>)<br><code>第一趟(步长为4)：</code></p>
<blockquote>
<p>原列表 4 6 8 2 9 3 7 5 1，分组后为：<br>4 6 8 2<br>9 3 7 5<br>1<br>排序后为：<br>1 3 7 2<br>4 6 8 5<br>9<br>即排序后列表顺序为：<br>1 3 7 2 4 6 8 5 9</p>
</blockquote>
<p><code>第二趟(步长为2)</code></p>
<blockquote>
<p>待排序列表1 3 7 2 4 6 8 5 9，分组后为：<br>1 3<br>7 2<br>4 6<br>8 5<br>9<br>排序后为：<br>1 2<br>4 3<br>7 5<br>8 6<br>9<br>即排序后列表顺序为：<br>1 2 4 3 7 5 8 6 9</p>
</blockquote>
<p><code>第三趟(步长为1), 即直接插入排序</code></p>
<blockquote>
<p>待排序列表1 2 4 3 7 5 8 6 9<br>排序后列表顺序为：1 2 3 4 5 6 7 8 9</p>
</blockquote>
<h4 id="算法优劣分析-3"><a href="#算法优劣分析-3" class="headerlink" title="算法优劣分析"></a>算法优劣分析</h4><ul>
<li>希尔排序比插入排序要快，甚至在小数组中比<strong>快速排序</strong>和<strong>堆排序</strong>还快，但是在涉及大量数据时希尔排序还是比<strong>快速排序</strong>慢。</li>
<li>不稳定</li>
<li>平均时间复杂度O(nlog2n)「n倍的log以2为底n」<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><strong><em>巧记：将直接插入算法的步长从1改为gap，加入限制条件gap &gt; 0即可</em></strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding = utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, list_=[])</span>:</span></span><br><span class="line">		self.list_ = list_</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_current_list</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.list_</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ascent_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">		gap = len(self.list_)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(self.list_)):</span><br><span class="line">				current_value = self.list_[i]</span><br><span class="line">				position = i	</span><br><span class="line">				<span class="keyword">while</span> position &gt;<span class="number">0</span> <span class="keyword">and</span> self.list_[position - gap] &gt; current_value:</span><br><span class="line">					self.list_[position] = self.list_[position - gap]</span><br><span class="line">					position = position - gap</span><br><span class="line">				self.list_[position] = current_value</span><br><span class="line">			gap = gap/<span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> self.list_</span><br><span class="line"></span><br><span class="line">list1 = ShellSort([<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_list()</span><br></pre></td></tr></table></figure>
<h2 id="5-归并排序-Merge-Sort"><a href="#5-归并排序-Merge-Sort" class="headerlink" title="5. 归并排序(Merge Sort)"></a>5. 归并排序(Merge Sort)</h2><h4 id="自然语言描述-4"><a href="#自然语言描述-4" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><p>将两个有序表合并成一个有序表。归并排序算法依赖于归并操作。<br><img src="http://upload-images.jianshu.io/upload_images/8741154-ac731598637727b3.gif?imageMogr2/auto-orient/strip" alt="from Wikipedia"></p>
<blockquote>
<p>两个有序表，left = [0,3,5,7], right = [1,4]，<br>合成的有序列表result = []<br>left[0] &lt; right[0]  —-&gt;  result = [0]<br>left[1] &gt; right[0] —-&gt;  result = [0,1]<br>left[1] &lt; right[1] —-&gt; result = [0,1,3]<br>left[2] &gt; right[1] —-&gt; result = [0,1,3,4]<br>此时right[]为空，将left[]剩余的元素依次放入result列表中：result = [0,1,3,4,5,7]</p>
</blockquote>
<h4 id="两种核心算法"><a href="#两种核心算法" class="headerlink" title="两种核心算法"></a>两种核心算法</h4><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><p><a href="http://www.jianshu.com/p/3ad5373465fd" target="_blank" rel="external">递归算法思想参考这里</a></p>
<blockquote>
<p>设计递归，将复杂的问题分解为最小规模子问题。</p>
<ul>
<li>将列表分解为 两个更小的列表。</li>
<li><strong><em>递归分解，将更小的列表继续分解，直到达到最小规模，也就是只有一个元素的时候</em></strong>。</li>
<li>对已经排序好的列表 进行合并。单个元素的列表，认为是已经排序好的。</li>
</ul>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/8741154-25e9d65aace0f91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="from Wikipedia"></p>
<h6 id="递归python实现"><a href="#递归python实现" class="headerlink" title="递归python实现"></a>递归python实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding=utf-8-*-</span></span><br><span class="line"><span class="comment">#递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(seq=[])</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(seq) == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> seq</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		mid = len(seq)/<span class="number">2</span></span><br><span class="line">		left = []</span><br><span class="line">		right = []</span><br><span class="line">		left = mergeSort(seq[:mid])</span><br><span class="line">		right = mergeSort(seq[mid:])</span><br><span class="line">		<span class="keyword">return</span> merge(left,right)</span><br><span class="line"><span class="comment">#将排好序的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left=[],right=[])</span>:</span></span><br><span class="line">	<span class="comment">#i, j are index for left and right seperately</span></span><br><span class="line">	i, j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">	result = []</span><br><span class="line">	<span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">		<span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">			result.append(left[i])</span><br><span class="line">			i = i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			result.append(right[j])</span><br><span class="line">			j = j + <span class="number">1</span></span><br><span class="line">	<span class="comment">#将剩余的部分依次加入result</span></span><br><span class="line">	result = result + left[i:]</span><br><span class="line">	result = result + right[j:]</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">list1 = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">print</span> list1</span><br><span class="line"><span class="keyword">print</span> mergeSort(list1)</span><br><span class="line"><span class="comment">#time consume</span></span><br><span class="line"><span class="keyword">import</span> random,time</span><br><span class="line">start_time = time.time()</span><br><span class="line">seq = random.sample(range(<span class="number">10000</span>), <span class="number">10000</span>) <span class="comment">#random.sample(取值范围, 获取的个数)</span></span><br><span class="line">result = mergeSort(seq)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Time consume:&#123;&#125;'</span>.format(time.time()-start_time)</span><br></pre></td></tr></table></figure>
<h6 id="非递归法（迭代法）"><a href="#非递归法（迭代法）" class="headerlink" title="非递归法（迭代法）"></a>非递归法（迭代法）</h6><p>从最小的子问题开始解决，直到复杂的问题。要搞清每次排序归并的对象。<br><img src="http://upload-images.jianshu.io/upload_images/4131789-ae20b2d875793547.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="非递归算法（迭代法）"></p>
<p>第一次：我们将数组分为 8个子数组 每个数组 1 个元素，对相邻的两个数组进行排序合并。<br>第二次：我们将数组分为 4个子数组 每个数组 2 个元素，对相邻的两个数组进行排序合并。<br>第三次：我们将数组分为 2个子数组 每个数组 4 个元素，对相邻的两个数组进行排序合并。<br>至此：排序完毕。<br><strong><em>分析</em></strong><br>第一步：每一次子数组的元素个数</p>
<blockquote>
<p>k = 1 #子数组的个数<br>while k &lt;len(seq):<br>      k = k*2</p>
</blockquote>
<p>第二步：确定要合并的两个相邻数组的区间[low:mid)[mid:height)</p>
<blockquote>
<p>low = low(之前的low) +2<em>k<br>mid = low(现在的low)+k<br>height = low(现在的low) + 2</em>k<br>并且，<br>height不能越界（不能超过数组长度）；<br>mid不能大于height（mid大于height说明此时子数组个数不足k，那么这个时候该子数组不给予拆分直接pass，下图给予说明）</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/4131789-6dc1e77c241898fa.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="来自http://www.jianshu.com/p/3f27384387c1"></p>
<h6 id="非递归python实现"><a href="#非递归python实现" class="headerlink" title="非递归python实现"></a>非递归python实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-:-coding=utf-8-*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,seq=[])</span>:</span></span><br><span class="line">		self.seq = seq</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_current_seq</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.seq</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">ascent_sort</span><span class="params">(self)</span>:</span></span><br><span class="line">		k = <span class="number">1</span>         <span class="comment">#子数组元素的个数</span></span><br><span class="line">		<span class="keyword">while</span> k &lt; len(self.seq):</span><br><span class="line">			low = <span class="number">0</span></span><br><span class="line">			<span class="keyword">while</span> low &lt; len(self.seq):</span><br><span class="line">				height = min(low + <span class="number">2</span>*k, len(self.seq))</span><br><span class="line">				mid = low + k</span><br><span class="line">				<span class="keyword">if</span> mid &lt; height:</span><br><span class="line">					<span class="string">'''mergeSort'''</span></span><br><span class="line">					left = self.seq[low:mid]</span><br><span class="line">					right = self.seq[mid:height]</span><br><span class="line">					result =[]</span><br><span class="line">					i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">					<span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">						<span class="keyword">if</span> left[i] &lt; right[j]:</span><br><span class="line">							result.append(left[i])</span><br><span class="line">							i += <span class="number">1</span></span><br><span class="line">						<span class="keyword">else</span>:</span><br><span class="line">							result.append(right[j])</span><br><span class="line">							j += <span class="number">1</span></span><br><span class="line">					result = result + left[i:]</span><br><span class="line">					result = result + right[j:]</span><br><span class="line">					<span class="string">'''将原始数组的[low,height)替代为已经排好序的数组'''</span></span><br><span class="line">					self.seq[low:height] = result</span><br><span class="line">				low = low + <span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">			k *= <span class="number">2</span></span><br><span class="line">		<span class="keyword">return</span> self.seq</span><br><span class="line">list1 = MergeSort([<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> list1.get_current_seq()</span><br><span class="line">list1.ascent_sort()</span><br><span class="line"><span class="keyword">print</span> list1.get_current_seq()</span><br></pre></td></tr></table></figure>
<h2 id="6-堆排序-HeapSort"><a href="#6-堆排序-HeapSort" class="headerlink" title="6. 堆排序(HeapSort)"></a>6. 堆排序(HeapSort)</h2><p>堆排序是对简单选择排序的一种优化。<br>堆的定义及性质见<a href="http://www.jianshu.com/p/42d08c8ed18a" target="_blank" rel="external">这里</a>。</p>
<h4 id="堆的主要性质："><a href="#堆的主要性质：" class="headerlink" title="堆的主要性质："></a><strong>堆的主要性质</strong>：</h4><ul>
<li>若根的index为1，则最后一个非叶子节点的index为len(seq)/2。此时对于index为i的节点，其左节点的index为2<em>i；右节点的index为2</em>i+1。</li>
<li>若根的index为0，最后一个非叶子节点的index为len(seq)/2-1。此时对于index为i的节点；其左节点的index为2<em>i+1，右节点的index为2</em>i+2。</li>
</ul>
<h4 id="堆排序需要解决两个主要的问题："><a href="#堆排序需要解决两个主要的问题：" class="headerlink" title="堆排序需要解决两个主要的问题："></a>堆排序需要解决两个主要的问题：</h4><ul>
<li>P1：如何将无序的列表构建成最小堆<br><img src="http://upload-images.jianshu.io/upload_images/1894691-cb4e77ab86413fd9.png?imageMogr2/auto-orient/strip" alt="P1：如何从无序数组构建最小堆"></li>
<li>P2：将最小堆的顶部取出后如何重建最小堆<br><img src="http://upload-images.jianshu.io/upload_images/1894691-49f3c7196f85fe6f.png?imageMogr2/auto-orient/strip" alt="P2：如何重构最小堆"></li>
</ul>
<p>堆排序过程演示：<br><img src="http://upload-images.jianshu.io/upload_images/4251424-e997b3365c9aa77f.gif?imageMogr2/auto-orient/strip" alt="from Wikipedia"></p>
<h4 id="堆排序的三个步骤："><a href="#堆排序的三个步骤：" class="headerlink" title="堆排序的三个步骤："></a>堆排序的三个步骤：</h4><ul>
<li>构建堆</li>
<li>调整堆</li>
<li>堆排序</li>
</ul>
<h4 id="堆排序python实现"><a href="#堆排序python实现" class="headerlink" title="堆排序python实现"></a>堆排序python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding=utf-8-*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="string">"""建立一个堆"""</span></span><br><span class="line">    <span class="comment">#根据完全二叉树的性质，根的index为0，非叶子节点的index为1至len(seq)/2-1，</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)/<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        max_heap(seq, len(seq), i)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heap</span><span class="params">(seq, heap_size, index)</span>:</span></span><br><span class="line">    <span class="string">"""调整列表中的元素以保证以index为根的堆是一个最大堆---&gt;从而最终得到从小到大的排列顺序"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将当前结点与其左右子节点比较，将较大的结点与当前结点交换，然后递归地调整子树</span></span><br><span class="line">    left_child = <span class="number">2</span> * index + <span class="number">1</span></span><br><span class="line">    right_child = left_child + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left_child &lt; heap_size <span class="keyword">and</span> seq[left_child] &gt; seq[index]:</span><br><span class="line">        largest = left_child</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = index</span><br><span class="line">    <span class="keyword">if</span> right_child &lt; heap_size <span class="keyword">and</span> seq[right_child] &gt; seq[largest]:</span><br><span class="line">        largest = right_child</span><br><span class="line">    <span class="keyword">if</span> largest != index:</span><br><span class="line">        seq[index], seq[largest] = seq[largest], seq[index] <span class="comment">#python特有，不需temp</span></span><br><span class="line">        max_heap(seq, heap_size, largest)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(to_sort_list)</span>:</span></span><br><span class="line">    <span class="string">"""堆排序"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先将列表调整为堆</span></span><br><span class="line">    build_max_heap(to_sort_list)</span><br><span class="line">    heap_size = len(to_sort_list)</span><br><span class="line">    <span class="comment"># 调整后列表(此时为堆）的第一个元素就是这个列表中最大的元素，将其与最后一个元素交换，然后将剩余的列表再调整为最大堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(to_sort_list) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        to_sort_list[i], to_sort_list[<span class="number">0</span>] = to_sort_list[<span class="number">0</span>], to_sort_list[i]</span><br><span class="line">        heap_size -= <span class="number">1</span></span><br><span class="line">        max_heap(to_sort_list, heap_size, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">   </span><br><span class="line">to_sort_list = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">heap_sort(to_sort_list)</span><br><span class="line"><span class="keyword">print</span> to_sort_list</span><br></pre></td></tr></table></figure>
<h4 id="算法优劣分析-4"><a href="#算法优劣分析-4" class="headerlink" title="算法优劣分析"></a>算法优劣分析</h4><ul>
<li>平均时间复杂度O(nlogn)</li>
<li>空间复杂度O(1)</li>
</ul>
<h2 id="7-快速排序-QuikSort"><a href="#7-快速排序-QuikSort" class="headerlink" title="7. 快速排序(QuikSort)"></a>7. 快速排序(QuikSort)</h2><h4 id="自然语言描述-5"><a href="#自然语言描述-5" class="headerlink" title="自然语言描述"></a>自然语言描述</h4><p>对冒泡排序的有效改进。快速排序是一种不稳定的排序算法，<strong>即多个相同的值的相对位置也许会在算法结束时产生变动</strong>。</p>
<p>假设要排序的列表<code>a[0]</code>,<code>a[1]</code>…<code>a[n-1]</code>，首先任意选取一个数据（通常选用<code>a[0]</code>）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。整个排序过程可以递推进行，从而使整个列表变得有序。</p>
<p><strong><em>更具体一些：</em></strong></p>
<ul>
<li>设置两个变量<code>i</code>、<code>j</code>，排序开始的时候：<code>i=0</code>，<code>j=n-1</code>；</li>
<li>以第一个数组元素作为关键数据，赋值给<code>key</code>，即<code>key = a[0]</code>；</li>
<li>从<code>j</code>开始向前搜索 (顺序不能调转，因为你的比较对象是<code>a[0]</code>)，即由后开始向前搜索，找到第一个小于<code>key</code>的值<code>list[j]</code>，将<code>list[j]</code>赋值给<code>list[i]</code>, 并令<code>i++</code>；</li>
<li>从<code>i</code>开始向后搜索，即由前开始向后搜索，找到第一个大于<code>key</code>的<code>list[i]</code>，将<code>list[i]</code>赋值给<code>list[j]</code>，并令<code>j--</code>；</li>
<li>重复第3、4步，直到<code>i = j</code>（下面有图解说明这一结束条件）。<br><strong><em>Note:</em></strong></li>
<li>3,4步中，没找到符合条件时，改变<code>j</code>、<code>i</code>的值，使得<code>j = j-1</code>，<code>i = i+1</code>，直至找到为止。</li>
<li>找到符合条件的值，进行交换的时候<code>i</code>， <code>j</code>指针位置不变，只交换所指的值。</li>
<li><code>i == j</code>这一过程一定正好是<code>i++</code>或<code>j--</code>完成的时候，此时令循环结束。</li>
</ul>
<p><strong>不多说了，上图！</strong></p>
<p><strong>一趟比较的图解：</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/8741154-12890818c6bd95e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字太丑凑活看"></p>
<h4 id="快速排序python实现"><a href="#快速排序python实现" class="headerlink" title="快速排序python实现"></a>快速排序python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding=UTF-8-*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(a,left,right)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> len(a) &lt;= <span class="number">1</span> <span class="keyword">or</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> left &gt;= len(a) <span class="keyword">or</span> right &lt;= left:</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	key = a[left]</span><br><span class="line">	i, j = left, right</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> i &lt; j:</span><br><span class="line">		<span class="keyword">while</span> a[j] &gt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> a[j] &lt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">			a[i] = a[j]</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> a[i] &lt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> a[i] &gt; key <span class="keyword">and</span> i &lt; j:</span><br><span class="line">			a[j] = a[i]</span><br><span class="line">			j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	a[i] = key</span><br><span class="line">	quick_sort(a, left, i<span class="number">-1</span>)</span><br><span class="line">	quick_sort(a, i+<span class="number">1</span>, right)</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">67</span>,<span class="number">23</span>,<span class="number">89</span>,<span class="number">35</span>,<span class="number">28</span>,<span class="number">90</span>,<span class="number">10</span>,<span class="number">24</span>]</span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = len(list1)<span class="number">-1</span></span><br><span class="line">print(quick_sort(list1, left, right))</span><br></pre></td></tr></table></figure>
<h2 id="总结比较"><a href="#总结比较" class="headerlink" title="总结比较"></a>总结比较</h2><p><img src="http://upload-images.jianshu.io/upload_images/4251424-8d79360387a74e70.png?imageMogr2/auto-orient/strip" alt="七大算法的比较"></p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


    <hr />
    <h3>Kommentare:</h3>
    <div id="fb-root"></div>
    <script>
        (function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=824671024381046";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
    </script>

    <div class="fb-comments" data-href="http://yoursite.com/2017/09/03/七大排序算法解析与Python实现/index.html" data-num-posts="5" data-width="100%" data-colorscheme="light"></div>

                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    
                        <li>
                            <a href="https://www.facebook.com/AnJingjing511" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    
                        <li>
                            <a href="https://github.com/crystalajj" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 An Jingjing<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>